#### 一、二叉树遍历模板

> 1. 前序遍历
>
>    * 递归算法
>
>      ``` c
>      /**
>       * Definition for a binary tree node.
>       * struct TreeNode {
>       *     int val;
>       *     struct TreeNode *left;
>       *     struct TreeNode *right;
>       * };
>       */
>      //递归的模板
>      void preOrderTree(struct TreeNode *root){
>          if(!root){
>              return 0;
>          }
>          visit(root);
>          PreOrderTree(root->left);
>          PreOrderTree(root->right);
>              
>      }
>      
>      void preOrderTree(struct TreeNode *root,int *ret,int * retIndex){
>          if(!root){
>              return 0;
>          }
>          // 递归先序遍历，使用到模板
>          // 访问结点
>          ret[(*retIndex++)]=root->val;
>          // 访问左子树
>          preOrderTree(root->left,ret,retIndex);
>          // 访问右子树
>          preOrderTree(root->right,ret,retIndex);
>      }
>      int* preorderTraversal(struct TreeNode* root, int* returnSize){
>          int *retIndex = 0;
>          int *ret = (int *)malloc(sizeof(int)*100);
>          memset(ret,0,sizeof(int)*100);
>          preOrderTree(root,ret,retIndex);
>          // 细节 retIndex由于是++ 这不是同时指向当前的数，是错开一个
>          // 指向当前结点的后一个，所有的循环退出都是如此
>          *returnSize = *retIndex;
>          // 对返回值负责
>          return ret;
>      }
>      ```
>
>    * 非递归（迭代算法）
>    
>      ``` 
>      
>      ```
>    
>      
>    
> 2. 中序遍历
>
>    * 递归算法
>
>      ``` c
>      //递归的模板
>      void inOrderTree(struct TreeNode *root){
>          if(!root){
>              return 0;
>          }
>          inOrderTree(root->left);
>          visit(root);
>          inOrderTree(root->right);
>      
>      }
>      
>      void inorder(struct TreeNode* root,int* returnSize,int *a)/*中序遍历二叉树*/
>      {
>          if(!root) 
>              return;
>          // 访问左孩子
>          inorder(root->left,returnSize,a);
>          // 访问节点
>          a[(*returnSize)++]=root->val;
>          // 访问右孩子
>          inorder(root->right,returnSize,a);
>      
>      }
>      int size(struct TreeNode* root)/*求二叉树数据个数*/
>      {	
>          // 递归求解二叉树结点数
>          if(!root) return 0;
>          return size(root->left)+size(root->right)+1;
>      }
>      int* inorderTraversal(struct TreeNode* root, int* returnSize){
>          int treesize=size(root);
>          int *a=(int*)malloc(treesize*sizeof(int));
>          memset(a,0,treesize);
>          *returnSize=0;
>          inorder(root,returnSize,a);
>          return a;
>      }
>      ```
>
>    * 非递归算法
>
>      ```
>      
>      ```
>
>      
>
> 3. 后序遍历
>
>    * 递归算法
>
>      ```c
>      //递归的模板
>      void inOrderTree(struct TreeNode *root){
>          if(!root){
>              return 0;
>          }
>          inOrderTree(root->left);
>          visit(root);
>          inOrderTree(root->right);
>              
>      }
>      
>      void postTree(struct TreeNode* root,int *ret,int *retIndex){
>          if(!root){
>              return ;
>          }
>          // 访问左孩子
>          postTree(root->left,ret,retIndex);
>          // 访问右孩子
>          postTree(root->right,ret,retIndex);
>          // 访问节点
>          ret[(*retIndex)++]=root->val;
>      }
>      int* postorderTraversal(struct TreeNode* root, int* returnSize){
>          int *ret = (int *)malloc(sizeof(int)*100);
>          int retIndex = 0;
>          postTree(root,ret,&retIndex);
>          *returnSize = retIndex;
>          return ret;
>      }
>      
>      ```
>
>    * 非递归算法
>
>      ```
>      
>      ```
>
>      
>
>    

